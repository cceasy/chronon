import mill.api._
import mill.scalalib._
import mill.scalalib.scalafmt._
import mill.scalalib.publish._
import coursier.maven.MavenRepository

// Shared constants and dependencies
object Constants {
  // Common repositories
  def repositories = Seq(
    MavenRepository("https://repo1.maven.org/maven2/"),
    MavenRepository("https://packages.confluent.io/maven/"),
    MavenRepository("https://linkedin.jfrog.io/artifactory/avro-util/"),
    MavenRepository("https://repository.apache.org/content/repositories/releases/"),
    MavenRepository("https://conjars.org/repo/")
  )

  val defaultScalaVersion = "2.12.18"
  val scalaVersions = Seq(defaultScalaVersion, "2.13.17")

  val jvmId = ""

  // Publishing configuration
  val organization = "ai.zipline"
  val projectUrl = "https://github.com/zipline-ai/chronon"
  val vcsUrl = "https://github.com/zipline-ai/chronon"
  val licenses = Seq(License.`Apache-2.0`)
  val developers = Seq(
    Developer("zipline-ai", "Zipline AI", "https://github.com/zipline-ai")
  )

  def pomSettingsFor(artifactId: String) = PomSettings(
    description = artifactId,
    organization = organization,
    url = projectUrl,
    licenses = licenses,
    versionControl = VersionControl.github("zipline-ai", "chronon"),
    developers = developers
  )

  // Common dependencies
  def commonDeps = Seq(
    mvn"org.scala-lang.modules::scala-collection-compat:2.6.0",
    mvn"org.scala-lang.modules::scala-parser-combinators:2.3.0",
    mvn"org.scala-lang.modules::scala-java8-compat:1.0.2"
  )

  def loggingApiDeps = Seq(
    mvn"org.slf4j:slf4j-api:1.7.36"
  )

  def loggingDeps = loggingApiDeps ++ Seq(
    mvn"ch.qos.logback:logback-classic:1.5.19",
    mvn"ch.qos.logback:logback-core:1.5.19",
    // Used for structured JSON logging
    mvn"net.logstash.logback:logstash-logback-encoder:9.0"
  )

  def utilityDeps = Seq(
    mvn"com.fasterxml.jackson.core:jackson-core:2.15.2",
    mvn"com.fasterxml.jackson.core:jackson-databind:2.15.2",
    mvn"com.fasterxml.jackson.core:jackson-annotations:2.15.2",
    mvn"com.fasterxml.jackson.module::jackson-module-scala:2.15.2",
    mvn"com.google.code.gson:gson:2.10.1",
    mvn"org.apache.commons:commons-lang3:3.18.0",
    mvn"org.apache.commons:commons-math3:3.6.1",
    mvn"org.apache.commons:commons-pool2:2.11.1",
    mvn"commons-io:commons-io:2.9.0",
    mvn"com.google.guava:guava:33.3.1-jre",
    mvn"org.yaml:snakeyaml:2.3",
    mvn"com.typesafe:config:1.4.3",
    mvn"javax.annotation:javax.annotation-api:1.3.2"
  )

  def testDeps = Seq(
    mvn"org.scalatest::scalatest:3.2.15",
    mvn"org.scalatest::scalatest-shouldmatchers:3.2.15",
    mvn"org.scalactic::scalactic:3.2.15",
    mvn"org.mockito:mockito-core:5.12.0",
    mvn"org.mockito::mockito-scala:1.17.0",
    mvn"org.scalatestplus::mockito-3-4:3.2.10.0",
    mvn"junit:junit:4.13.2",
    mvn"com.novocode:junit-interface:0.11"
  )

  // Version definitions
  val sparkVersion = "3.5.3"
  def sparkDeps = Seq(
    mvn"org.apache.spark::spark-core:$sparkVersion",
    mvn"org.apache.spark::spark-sql:$sparkVersion", 
    mvn"org.apache.spark::spark-catalyst:$sparkVersion",
    mvn"org.apache.spark::spark-hive:$sparkVersion",
    mvn"org.apache.hudi::hudi-spark3.5-bundle:1.0.0",
    mvn"org.apache.hadoop:hadoop-client-api:3.3.6",
    mvn"org.apache.hadoop:hadoop-client-runtime:3.3.6",
    mvn"org.apache.iceberg::iceberg-spark-runtime-3.5:1.10.0",
  )
  
  val flinkVersion = "1.17.0"
  def providedFlinkDeps = Seq(
    mvn"org.apache.flink:flink-streaming-java:$flinkVersion",
    mvn"org.apache.flink:flink-clients:$flinkVersion",
  )
  
  val protobufVersion = "3.25.5"
  
  // Common JVM arguments for all test modules
  def commonTestForkArgs = Seq(
    "--add-opens=java.base/java.lang=ALL-UNNAMED",
    "--add-opens=java.base/java.lang.invoke=ALL-UNNAMED",
    "--add-opens=java.base/java.lang.reflect=ALL-UNNAMED",
    "--add-opens=java.base/java.io=ALL-UNNAMED",
    "--add-opens=java.base/java.net=ALL-UNNAMED",
    "--add-opens=java.base/java.nio=ALL-UNNAMED",
    "--add-opens=java.base/java.util=ALL-UNNAMED",
    "--add-opens=java.base/java.util.concurrent=ALL-UNNAMED",
    "--add-opens=java.base/java.util.concurrent.atomic=ALL-UNNAMED",
    "--add-opens=java.base/sun.nio.ch=ALL-UNNAMED",
    "--add-opens=java.base/sun.nio.cs=ALL-UNNAMED",
    "--add-opens=java.base/sun.security.action=ALL-UNNAMED",
    "--add-opens=java.base/sun.util.calendar=ALL-UNNAMED",
    "-Dorg.slf4j.simpleLogger.defaultLogLevel=ERROR",
    "-Dlogback.configurationFile=logback-test.xml",
    // Disable multi-release JAR processing to avoid path issues
    "-Djdk.util.jar.enableMultiRelease=false"
  )

  // GCS publishing configuration
  val defaultGcsBucket = "gs://zipline-artifacts-canary"
  val defaultGcsBasePath = "release"
}

// Custom PublishModule trait that adds GCS publishing capabilities
trait GcsPublishModule extends PublishModule {
  // Self-type to ensure this trait is mixed with CrossScalaModule
  this: CrossScalaModule =>

  import java.time.Instant

  /**
   * GCS bucket to publish artifacts to. Override in modules to customize.
   */
  def gcsBucket: String = Constants.defaultGcsBucket

  /**
   * Base path within the GCS bucket. Override to customize.
   */
  def gcsBasePath: String = Constants.defaultGcsBasePath

  /**
   * Deploy artifact name for GCS. Defaults to artifactName + "_deploy.jar"
   */
  def gcsArtifactName: Task[String] = Task { s"${artifactName()}_deploy.jar" }

  /**
   * Whether this module should be published to GCS. Override to disable for specific modules.
   */
  def publishToGcsEnabled: Boolean = true

  /**
   * Get git metadata for artifact tagging
   */
  private def getGitMetadata(): Map[String, String] = {
    try {
      val commit = os.proc("git", "rev-parse", "HEAD").call().out.text().trim
      val branch = os.proc("git", "rev-parse", "--abbrev-ref", "HEAD").call().out.text().trim
      val date = Instant.now().toString
      Map(
        "commit" -> commit,
        "branch" -> branch,
        "updated_date" -> date
      )
    } catch {
      case e: Exception =>
        println(s"Warning: Could not get git metadata: ${e.getMessage}")
        Map("updated_date" -> Instant.now().toString)
    }
  }

  /**
   * Publish assembly JAR to GCS with metadata
   */
  def publishGcsAssembly() = Task.Command {
    if (!publishToGcsEnabled) {
      println(s"GCS publishing disabled for ${artifactName()}")
      ()
    } else {
      // Get the assembly jar path
      val jarPathRef = assembly()
      val jarPath = jarPathRef.path

      if (!os.exists(jarPath)) {
        throw new Exception(s"Assembly JAR not found at $jarPath. Run assembly task first.")
      }

      // Build GCS destination path
      val version = publishVersion()
      val scalaVer = scalaVersion()
      val deployName = gcsArtifactName()
      val gcsPath = s"$gcsBucket/$gcsBasePath/$version/jars/$deployName"

      println(s"Publishing ${artifactName()} to GCS...")
      println(s"  Version: $version")
      println(s"  Scala: $scalaVer")
      println(s"  Source: $jarPath")
      println(s"  Destination: $gcsPath")

      // Get git metadata
      val metadata = getGitMetadata() + ("scala_version" -> scalaVer)
      val metadataStr = metadata.map { case (k, v) => s"$k=$v" }.mkString(",")

      // Upload to GCS
      try {
        os.proc("gcloud", "storage", "cp", jarPath.toString, gcsPath)
          .call(stdout = os.Inherit, stderr = os.Inherit)

        // Set metadata
        os.proc(
          "gcloud", "storage", "objects", "update", gcsPath,
          s"--custom-metadata=$metadataStr"
        ).call(stdout = os.Inherit, stderr = os.Inherit)

        println(s"  ✓ Successfully published ${artifactName()} to $gcsPath")
      } catch {
        case e: Exception =>
          throw new Exception(s"Failed to publish to GCS: ${e.getMessage}", e)
      }
    }
  }

  /**
   * Publish JAR artifact (not assembly) to GCS
   */
  def publishGcsJar() = Task.Command {
    if (!publishToGcsEnabled) {
      println(s"GCS publishing disabled for ${artifactName()}")
      ()
    } else {
      // Get the JAR path
      val jarPathRef = jar()
      val jarPath = jarPathRef.path

      if (!os.exists(jarPath)) {
        throw new Exception(s"JAR not found at $jarPath.")
      }

      // Build GCS destination path
      val version = publishVersion()
      val scalaVer = scalaVersion()
      val jarName = s"${artifactName()}-${scalaVer}-${version}.jar"
      val gcsPath = s"$gcsBucket/$gcsBasePath/$version/libs/$jarName"

      println(s"Publishing ${artifactName()} JAR to GCS...")
      println(s"  Version: $version")
      println(s"  Scala: $scalaVer")
      println(s"  Source: $jarPath")
      println(s"  Destination: $gcsPath")

      // Get git metadata
      val metadata = getGitMetadata() + ("scala_version" -> scalaVer)
      val metadataStr = metadata.map { case (k, v) => s"$k=$v" }.mkString(",")

      // Upload to GCS
      try {
        os.proc("gcloud", "storage", "cp", jarPath.toString, gcsPath)
          .call(stdout = os.Inherit, stderr = os.Inherit)

        // Set metadata
        os.proc(
          "gcloud", "storage", "objects", "update", gcsPath,
          s"--custom-metadata=$metadataStr"
        ).call(stdout = os.Inherit, stderr = os.Inherit)

        println(s"  ✓ Successfully published ${artifactName()} JAR to $gcsPath")
      } catch {
        case e: Exception =>
          throw new Exception(s"Failed to publish JAR to GCS: ${e.getMessage}", e)
      }
    }
  }
}

// Base module configuration
trait BaseModule extends CrossScalaModule with ScalafmtModule with GcsPublishModule {
  def jvmId = Constants.jvmId

  def repositoriesTask = Task.Anon { super.repositoriesTask() ++ Constants.repositories }

  def scalacOptions = Seq(
    "-deprecation",
    "-feature",
    "-unchecked",
    "-language:implicitConversions",
    "-language:postfixOps",
    "-language:reflectiveCalls"
  )

  def javacOptions = Seq(
    "-source", "11",
    "-target", "11"
  )

  // Merge strategy for assembly
  override def assemblyRules = Assembly.defaultRules ++ Seq(
    Assembly.Rule.AppendPattern("META-INF/services/*", "\n")
  )

  // Include both Scala and Java sources, exclude test sources from main compilation
  override def sources = Task.Sources(
    moduleDir / "src" / "main" / "scala",
    moduleDir / "src" / "main" / "java"
  )

  // PublishModule implementation
  def pomSettings = PomSettings(
    description = artifactName(),
    organization = Constants.organization,
    url = Constants.projectUrl,
    licenses = Constants.licenses,
    versionControl = VersionControl.github("zipline-ai", "chronon"),
    developers = Constants.developers
  )

  // Override to read version from environment at task execution time
  override def publishVersion = Task { sys.env.getOrElse("CHRONON_VERSION", "0.0.32") }
}

// Common test module configuration
trait BaseTestModule extends ScalaModule with TestModule.ScalaTest {
  def jvmId = Constants.jvmId

  def testFramework = "org.scalatest.tools.Framework"

  // Use the same repositories as parent modules
  def repositoriesTask = Task.Anon { super.repositoriesTask() ++ Constants.repositories }

  // Override sources to use the correct test directory
  override def sources = Task.Sources(moduleDir / os.up / "src" / "test" / "scala")

  // Override resources to use the correct test resources directory
  override def resources = Task.Sources(moduleDir / os.up / "src" / "test" / "resources")

  // Enable parallel test execution using Mill's testParallelism
  def testParallelism = true
}

// JUnit 5 test module configuration (for Java tests)
trait BaseJUnitTestModule extends JavaModule with TestModule.Junit5 {
  def jvmId = Constants.jvmId
  // Use the same repositories as parent modules
  def repositoriesTask = Task.Anon { super.repositoriesTask() ++ Constants.repositories }

  // Override sources to use the correct test directory
  override def sources = Task.Sources(moduleDir / os.up / "src" / "test" / "java")

  // Override resources to use the correct test resources directory
  override def resources = Task.Sources(moduleDir / os.up / "src" / "test" / "resources")

  // Enable parallel test execution using Mill's testParallelism
  def testParallelism = true
}

// JUnit 4 test module configuration (for Java tests using JUnit 4)
trait BaseJUnit4TestModule extends JavaModule with TestModule.Junit4 {
  def jvmId = Constants.jvmId
  // Use the same repositories as parent modules
  def repositoriesTask = Task.Anon { super.repositoriesTask() ++ Constants.repositories }
  
  // Override sources to use the correct test directory
  override def sources = Task.Sources(moduleDir / os.up / "src" / "test" / "java")
  
  // Override resources to use the correct test resources directory
  override def resources = Task.Sources(moduleDir / os.up / "src" / "test" / "resources")
  
  // Enable parallel test execution using Mill's testParallelism
  def testParallelism = true
}
